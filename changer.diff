diff -u --new-file --recursive linux-229/CREDITS linux-229-changer/CREDITS
--- linux-229/CREDITS	Tue May 11 18:57:14 1999
+++ linux-229-changer/CREDITS	Wed May 19 00:25:31 1999
@@ -1292,6 +1292,17 @@
 D: XF86_8514
 D: cfdisk (curses based disk partitioning program)
 
+N: Jeroen Massar
+E: jmassar@unfix.org
+W: http://unfix.org
+W: http://unfix.org/members/jmassar
+D: /dev/changer
+D: unfix.org BOFH
+S: Jeroen Massar
+S: Gortmolenerf 46
+S: 2807 EJ, Gouda
+S: The Netherlands
+
 N: Mike McLagan
 E: mike.mclagan@linux.org
 W: http://www.invlogic.com/~mmclagan
diff -u --new-file --recursive linux-229/Documentation/Configure.help linux-229-changer/Documentation/Configure.help
--- linux-229/Documentation/Configure.help	Tue May 11 18:57:14 1999
+++ linux-229-changer/Documentation/Configure.help	Wed May 19 00:25:31 1999
@@ -259,6 +259,20 @@
 
   Most users will answer N here.
 
+/dev/changer
+CONFIG_CHANGER
+  This driver allows you to mount all the slots of a cd-changer at once,
+  and also use them at once... with auto-swapping ability.
+  The driver is totally transparant so for example you'll get /dev/changer3
+  which otherwise would be /dev/scd0 slot 3.
+  For updates, documentation and a small userland-tool check out:
+  http://unfix.org/projects/changer
+  Or for general news:
+  http://unfix.org/news
+  
+  If you are not sure, say N; unless you've got a cd-changer then say
+  Y ofcourse... you'll like it :)
+
 Network Block Device support
 CONFIG_BLK_DEV_NBD
   Saying Y here will allow your computer to be a client for network
diff -u --new-file --recursive linux-229/MAINTAINERS linux-229-changer/MAINTAINERS
--- linux-229/MAINTAINERS	Sat May  8 21:49:46 1999
+++ linux-229-changer/MAINTAINERS	Wed May 19 00:25:31 1999
@@ -220,6 +220,13 @@
 L:	netdev@roxanne.nuclecu.unam.mx
 S:	Maintained
 
+DEV/CHANGER
+P: Jeroen Massar
+M: jmassar@unfix.org
+W: http://unfix.org
+W: http://unfix.org/projects/changer
+S: Maintained
+
 DEVICE NUMBER REGISTRY
 P:	H. Peter Anvin
 M:	hpa@zytor.com
diff -u --new-file --recursive linux-229/Makefile linux-229-changer/Makefile
--- linux-229/Makefile	Wed May 19 02:09:22 1999
+++ linux-229-changer/Makefile	Wed May 19 00:26:00 1999
@@ -1,7 +1,7 @@
 VERSION = 2
 PATCHLEVEL = 2
 SUBLEVEL = 9
-EXTRAVERSION =
+EXTRAVERSION = -changer
 
 ARCH := $(shell uname -m | sed -e s/i.86/i386/ -e s/sun4u/sparc64/ -e s/arm.*/arm/ -e s/sa110/arm/)
 
diff -u --new-file --recursive linux-229/drivers/block/Config.in linux-229-changer/drivers/block/Config.in
--- linux-229/drivers/block/Config.in	Thu Apr 29 21:53:48 1999
+++ linux-229-changer/drivers/block/Config.in	Wed May 19 00:25:31 1999
@@ -96,6 +96,7 @@
 comment 'Additional Block Devices'
 
 tristate 'Loopback device support' CONFIG_BLK_DEV_LOOP
+tristate '/dev/changer support' CONFIG_CHANGER
 if [ "$CONFIG_NET" = "y" ]; then
   tristate 'Network block device support' CONFIG_BLK_DEV_NBD
 fi
diff -u --new-file --recursive linux-229/drivers/block/Makefile linux-229-changer/drivers/block/Makefile
--- linux-229/drivers/block/Makefile	Tue Apr 13 01:18:27 1999
+++ linux-229-changer/drivers/block/Makefile	Wed May 19 00:25:31 1999
@@ -94,6 +94,14 @@
   endif
 endif
 
+ifeq ($(CONFIG_CHANGER),y)
+  L_OBJS += changer.o
+else
+  ifeq ($(CONFIG_CHANGER),m)
+    M_OBJS += changer.o
+  endif
+endif
+
 ifeq ($(CONFIG_BLK_DEV_HD),y)
 L_OBJS += hd.o
 endif
diff -u --new-file --recursive linux-229/drivers/block/changer.c linux-229-changer/drivers/block/changer.c
--- linux-229/drivers/block/changer.c	Thu Jan  1 01:00:00 1970
+++ linux-229-changer/drivers/block/changer.c	Wed May 19 01:31:33 1999
@@ -0,0 +1,1305 @@
+/**********************************************************************************************************************
+  /dev/changer by Jeroen Massar aka fuzzel/unfix <jmassar@unfix.org>               http://unfix.org/projects/changer
+***********************************************************************************************************************
+ TAB=3
+
+ Copyright (C) 1999, Jeroen Massar
+
+ Introduction
+	Normally it isn't allowed to mount all the discs of a changer at once, that is because
+	when you mount one slot you can't change to another anymore, because the cdrom gets locked.
+	And ofcourse you'll have to unmount it and then you'll have to change discs by hand.
+	Ok you could do this with a script... but what if you want to share the drives with NFS or
+	Samba and you don't want people to have to hassle with the scripts... let alone when multiple
+	people try...
+
+ Description
+	This little wrapper solves this problem. When it is loaded by the kernel it seeks in the
+	Unified CdRom driver list and checks for changers (capacity>1&changable). It adds these
+	devices to an changer-internal list, opens them and adds them to the changer-devices minor
+	list. The devices changer:minor can then be mounted like any other normal cdrom device, as
+	it acts like a single cdrom device... The other minors can also be mounted at the same time
+	as the changer-wrapper will change to the appropriate slot when it needs access to it.
+
+ Features
+	See the History part for when what was added.
+	- Allows mounting of all discs in a changer at once.
+	- It's free.
+	- 42 : the solution to anything (at least according to the Hitchhikers Guide to the Galaxy...)
+
+ Future Features (things on my mind)
+	- Samba Config Editing (create cd-entries from the names on the cd's).
+	  Should be done in userspace with some kind of callback using cdrom stuff.
+	- mail changer@medusa.unfix.org if you got any ideas :)
+
+ Parameters
+ 	- BOOL	noauto		- Disable auto-changer-detection.
+ 	- STRING	exclude		- Exclude the devicenames from auto-changer-detection.
+
+ Revisions
+	A version number is simply the date of the driver. So 19780225 = 25 February 1978.
+	The newest version will always be available from the unfix.org at :
+		http://unfix.org/projects/changer
+	or on the backup at:
+		http://www.fuzzel.cistron.nl/unfix/projects/changer
+
+ Legal Mumbo Jumbo
+	Well first thing first its my idea, so I want my name to be kept with it too.
+	For the rest... it's for Linux - The Peoples Operating System, so copy it whenever
+	you can/want etc. see all the GPL info etc. If you got some additions etc. tell me about
+	them and I'll be glad to include them. See the GPL added to the end of this header.
+	Sidenote: if you like it send me a postcard of your country or region you live in.
+
+	My snailmail address:
+		Jeroen Massar
+		Gortmolenerf 46
+		2807 EJ Gouda
+		The Netherlands
+
+	I'll scan in all the cards I receive and put them onto the projects page :)
+
+ Acknowledgements
+	A lot of info on how to actually implement it came from md (the multiple-disk driver),
+	nbd (the network block driver) and the loop device, all of which use sub/child-devices.
+	I'd also like to thank the following persons:
+		Linus Torvalds, Alan Cox, et al
+			- for making Linux in the first place :)
+		Marc Zyngier
+			- for making the md driver which I learned this code from
+			  and as the md driver is also being used for my soft-RAID-0 /archive :)
+		Theodore Ts'o
+			- for the loop device, which I had a good look at for the request part.
+		David A. van Leeuwen, Jens Axboe, Scott Snyder and Erik Andersen
+			- for the standardization and maintainaince of the cdrom code and
+			  implementing the selection of disc-slots.
+		Paradigit Computer Store
+			- for having a Teac CD-C68E priced at 200 guilders.
+		Andrew Tridgell & The Samba Team
+			- for Samba, allowing me to share the changer to my NT Xterminal.
+		Emiel "Clone" Lensink, Pieter "Suf-Duck" de Boer, Jean-Paul "Corwin" Mars,
+			Jeroen "Spook" Akershoek, Vera "Fear" Mafait
+			- for being Un(f)iX...
+		Beer/Neworder & Andabata
+			- The hosting of unfix.org.
+		#linux.nl
+			- for the general laughter...
+		Thomas E. Dodd
+			- for the silly wrapper_open fix.
+
+ Detailed History (child=underlying lowleveldriver)
+	20 November 1998
+		- I bought a Teac CD-C68E 6-cd changer, though ATAPI for 200 guilders I couldn't
+		  go wrong and I didn't, it's great, I've simply put all my so-much-needed cd's
+		  in and voila, but when I wanted to access it I had to manually umount and mount
+		  it <grmbl>, that is not what I want todo each time so I needed a solution and
+		  I thought up /dev/changer, which should release me of the unmounts and make any
+		  changer look like it is are multiple seperate cd's. I hope many people can use
+		  this... and that this small token will be noted as one of my contributions to Linux.
+		- My NT Xterminal broke... for no apparent reason what so ever...
+	22 November 1998
+		- Ok got my NT Xterminal to work again... let's start this little project.
+		- Looked into the kernel source and found out that I'd best base this on cdrom.c
+		  and one of the "low-level" drivers. I've made the step to 2.1.123 so I can access
+		  my changer with more options as 2.1 supports the CDROM_SELECT_SLOT call which I need.
+		  And also the reporting of slots etc. which could come in handy.
+		- Hmmm I've read the cdrom documentation with xdvi... cool program :)
+		- Read in the cdrom-docs about setcd for Debian... did a dselect and hey... there's
+		  my way to read volume labels, allowing volume names to be used.
+	24 November 1998
+		- The module loads and doesn't crash the system :)
+		- Know probably know fully how I'm gonna solve this problem.
+		- Added an IOCTL called CHANGER_SET which will allow the set of a major:minor to
+		  be a device. When the IOCTL is called it registers the cdrom. It can also be used
+		  to unset the device.
+		- I only have to pass the IOCTL's to the sub-device and it should work...
+	25 November 1998
+		- Ok the thingy should work now...
+		- I'll have to write a userspace proggy first though...
+	26 November 1998
+		- Implementing scanning of the cdi list... for auto adding changers.
+		  This will only add cdroms with a capacity>1&changable named chg0, chg1 etc...
+		  The number is the minor. This lets me skip the userspace proggy... for now...
+		- Will add an 'exclude' parameter to allow exclusion of changers.
+		- Wh00pie... it works.. at least the cdrom.c wrapping... the request not (yet).
+		- Settings are now adapted from the child driver.
+		- The mask is set according to the child's inabilities...
+	28 November 1998
+		- Put only an end_request(0) into request, and when I mount a disc from slot 0
+		  it all goes well, altough it stops due to the failed request. When I remove the
+		  disc it senses it ok, also for other slots. So the IOCTL wrapper works. Now I'll
+		  have to work out the request.
+		- Fixed releasing of the child when I'd have no slots in use of the child.
+	16 March 1999 (RELEASED (bz2+tgz) - 1st public alpha)
+		- Coded the request part using a good look at the loop-driver.
+		- It starts to work much better now... as it actually reads data, at least
+		  I hear and see the cd change and then see a second or two of data transfer.
+		- 01:21 I can mount cd's! One problem... as the buffer's aren't invalidated all cd's seem
+		  the same to the system... I'll have to find out a way to invalidate them.
+	17 March 1999 (RELEASED (bz2+tgz) - 2nd public alpha - announced on c.o.l.a.)
+		- Implemented a spinlock for each child device. This should hold it from changing discs
+		  while a operation is in progress and then when another task gets scheduled.
+		- Added some documentation to clear up some of the weird things I did.
+		- 18:42 - IT WORKS!!!!! well except for slot 0 at my setup... hmmm... :)
+		  /me happy... it also works by listing to cd's at once eg: 'ls -la -R /cdrom/4' and list another
+		  on another tty and they will change every so often...
+	18 March 1999 (RELEASED (bz2+tgz) - 3rd public alpha)
+		- Implemented Debug levels.
+		- I now re-set the blk_size[major][minor] in changer_change_slot().
+		- And voila, accessing files work too, well it did before but then it had to be in the first
+		  1024 sectors of the cd, now it can be anywhere...
+		- Redesigned website to conform to new unfix.org style.
+		- Included it in such a way that it is kernel-tree ready, and people can compile and test it.
+	19 March 1999 
+		- Added the following things to ll_rw_block.c, which avoid some nasty deadlocks:
+			- Available/Get/Free Request, divides total left by two so the device can use the other.
+			- "Plugging without Deadlocking".
+		- Included /dev/changer support to my 2.2.2-ac7 kernel, rest of the releases will become diff's of kernels.
+		  This is required for the ll_rw_block.c changes and also allows kernel-inclusion of the device.
+		- Defined a CONFIG_CHANGER and added it to the 'Additional Block Devices' section.
+		- Totally integrated /dev/changer into the kernel source.
+	== CeBIT 1999 ==
+	23 March 1999
+		- Compiled and tested the thing, and it now works for 100%.
+	24 March 1999 (RELEASED (bz2+tgz)
+		- Changed the entries above from March 1998 in March 1999 as that is the current year now...
+		- Moved the invalidate_buffers() call to changer_change_slot() so all functions changing use it.
+		- changer_change_slot() will now only do a select_disc()+invalidate_buffer() when the current!=wanted
+		  this way buffers are kept when no slots are changed in between requests/commands which should speed
+		  up some stuff.
+		- Added tests for changer_change_slot(), whether the correct slot is actually selected or not.
+	01 April 1999
+		- Last 1st April of this Millenium :) No it ain't a joke... <grin>
+	07 April 1999 (RELEASED (bz2+tgz) beta 2)
+		- Fixed the wrapper_open function which was a very, non-obvious, stupid mistake.
+		  Thanx to Thomas E. Dodd <ted@cypress.com> for finding it and for for the fix :)
+	13 April 1999
+		- Started implementing multi-request possibility & request re-ordering.
+		- Fixed typo/cut&paste bug: CDC_CLOSE_TRAY+CDC_CLOSE_TRAY <-- see the point :)
+		  (This is at the capabilities checking part...)
+		  Changed to CDC_OPEN_TRAY|CDC_CLOSE_TRAY.
+		- Added some more sanity/paranoia checks.
+		- Thought out some more about the reordering... see TODO text at the request function.
+		- Cleaned up error messages.
+		- All functions now use kdevname() to display the device name instead of the number.
+		- Implemented DEVICE_TRY_LOCK.
+		- Implemented the Global Read/Write Lock, this should make it 100% SMP safe.
+	29 April 1999 (RELEASED (bz2+tgz) beta 3)
+		- All INFO messages are now defined at one place, avoiding duplicates.
+		  This way every text can be customized.
+		- Tested as 2.2.6-ac2-changer.
+	== Koninginnedag/Queensday (31 April) ==
+	01 May 1999
+		- Cleaned up some code.
+		- All functions now use bdevname() instead of kdevname().
+	02 May 1999
+		- Fixed changer_majors spinlock initialization.
+		  I'll probably have to check everywhere wether the major is in bound with that
+		  structure... rather strange that it didn't go wrong before...
+		- Added CHANGER_SET_LEVEL for setting the output levels runtime.
+		- Added CHANGER_GET for querying which device:slot is connected to what changer.
+		  Actually the reverse of CHANGER_SET...
+		- The changer_set structure now also contains a size field.
+		- The changer_set version is now independent of the /dev/changer version.
+		- Created a small tool (changertool) for using the ioctl's.
+	19 May 1999 (RELEASED (bz2+tgz) beta 4)
+		- Fixed some problem with the spinlocks not compiling because
+		  of changed semantics in the 2.2.8+ and gcc bitching about it...
+		- Tested as 2.2.9-changer.
+
+Status: (BETA HACK)
+	It works quite well (IMO), but it should be seen as a big hack, even though that the whole of
+	linux could be called a big hack... but it's a hack that works.
+	Currently it does what it is required todo.. but you don't want to know how and why :)
+	Especially as it doesn't actually open the device...
+
+   Why I say it works:
+	I've already upgraded heaven's Debian install from Hamm to Slink, by using the two cd's
+	in my Teac changer and using an apt filepath pointing to the /dev/changer mounted cd's,
+	and as I can still type this it like still works :)
+
+Notes:
+	- drive_status & media_changed also pass along a slot number... does it have to be changed first then?
+	- what do the get_fs()/set_fs() do?
+
+Todo's
+	( '-' = subject, '=' = status)
+	- It doesn't lock the drive, VFS discchange notification doesn't work.
+	  It does unlock though... the lock command doesn't get issued or something.
+	  = I probably know what I do wrong here...
+ 	- User space program for non-autodetected cd-roms (eg for drivers which are insmod'ed after /dev/changer).
+	  = Busy on that one.
+	- A changer can't actually use two slots at the same time... this is a technical problem
+	  so when one request requires a slot and another requires another the changer will keep changing
+	  between them... I've got a choice of a couple of methods to solve this:
+		1) Don't change in less then n seconds (handling only requests on that slot).
+		2) Alan Cox told me that I could put every slot per 1Gb and that the kernel would reorder it.
+		3) Command queue-ing & reordering (this could be an addition to ll_rw_block.c)
+			Just like my Atlas3... reorder commands so it's easier to get the data and thus speeding the process up.
+	  I'll firstly implement method 1, then I'll implement method 3 which would also be a great improvement for other
+	  drivers which could get a great improvement as they get semi-sequential requests. It should be able to disable it
+	  for seperate drives, especially for drives like the Atlas3 and alike which do it much better in hardware.
+	
+	- ** CLEANUP THE CODE...
+	  = It's quite clean but it can be much cleaner and "nicer".
+	  = Some people want it to be in K&R style, but running an `ident -kr -i8` over it actually makes the source
+		 longer, I actually do catch else's.... IMHO my code is quite cleanly written if you can point me out
+		 otherwise do so but do it with actual arguments, I certainly don't use goto's...
+	- Optimize where possible, as it seems somewhat slower than direct drive mode.
+	  - Use bigger blocksizes where possible?
+	- Add/Remove paranoia checks?
+		- Checks for non-existing ioctls.
+	- Parameter handling.
+	- SysCtl Interface (cdrom_sysctl_register() and friends)
+		- a `cat /proc/sys/dev/changer` would show mappings eg:
+			8<--------------------------------------
+			Changer information
+			<device>	<minors>
+			hdc		0,1,2,3,4,5
+			scd0		6,7,8,9,10,11,12,13,14
+			-------------------------------------->8
+
+ Bugs:
+	- see the ToDo list.
+	- If you've got/found any new problems/bugs/suggestions then `vi messy;cat messy|mail changer@medusa.unfix.org`.
+
+ Other Notes:
+	- This driver obviously doesn't have the CDC_SELECT_DISC capability... <grin>
+
+*** Mental Notes *******************************************************************************************************
+#define you the_one_reading_this()
+#define me	"Jeroen Massar"
+if (you==me)
+{
+ Changes to files, eg what the diff-patch changes to a kernel source.
+	- include/linux/blk.h				- Added device entry.									- see CHANGER_MAJOR
+	- include/linux/major.h				- Added CHANGER_MAJOR = 42								- see CHANGER_MAJOR
+	- init/main.c							- Added changer_setup()									- see CONFIG_CHANGER
+												- Added device number.									- see CONFIG_CHANGER
+	- cdrom/Makefile						- Added objects.											- see changer.o
+	- cdrom/Config.in						- Added compilation stuff.								- see CONFIG_CHANGER
+	- block/ll_rw_blk.c					- Added changer_init()									- see CONFIG_CHANGER
+												- Added 'Plugging without Deadlocking' support	- see CHANGER_MAJOR
+	- Documentation/Configure.help	- Added help text.										- see CONFIG_CHANGER
+}
+
+***********************************************************************************************************************
+ GNU Public License
+***********************************************************************************************************************
+	This program is free software; you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation; either version 2 of the License, or
+	(at your option) any later version.
+	
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+	
+	You should have received a copy of the GNU General Public License
+	along with this program; if not, write to the Free Software
+	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+
+**********************************************************************************************************************/
+
+/**********************************************************************************************************************
+  Global Static Definitions
+**********************************************************************************************************************/
+#include <linux/changer.h>
+
+const char c_full[]	= CHANGER_FULL;
+const char c_short[]	= CHANGER_SHORT;
+const char c_date[]	= CHANGER_DATE;
+const char c_by[]		= CHANGER_AUTHOR;
+const char c_www[]	= CHANGER_WWW;
+const char c_list[]	= CHANGER_LIST;
+
+/* I'll use 42 as a testing major number (see major.h and blk.h). */
+/* This is correct per Documention/Devices.txt, I'll request a real one shortly.. */
+#define MAJOR_NR CHANGER_MAJOR
+
+/**********************************************************************************************************************
+  Export Prototypes
+**********************************************************************************************************************/
+static int changer_init(void);
+static void changer_cleanup(void);
+static int changer_change_slot(int minor);
+static int changer_set(struct cdrom_device_info *cdi,struct changer_set *set);
+
+/* wraps */
+static int changer_wrap_open(struct cdrom_device_info *cdi);
+static void changer_wrap_release(struct cdrom_device_info *cdi);
+
+/* blkdev */
+static void do_changer_request(void);
+
+/* for cdrom.c... */
+static int changer_open(struct cdrom_device_info *cdi,int purpose);
+static void changer_release(struct cdrom_device_info *cdi);
+static int changer_drive_status(struct cdrom_device_info *cdi,int slot_nr);
+static int changer_media_changed(struct cdrom_device_info *cdi,int disc_nr);
+static int changer_tray_move(struct cdrom_device_info *cdi,int position);
+static int changer_lock_door(struct cdrom_device_info *cdi,int lock);
+static int changer_select_speed(struct cdrom_device_info *cdi,int speed);
+static int changer_get_last_session(struct cdrom_device_info *cdi,struct cdrom_multisession *ms_info);
+static int changer_get_mcn(struct cdrom_device_info *cdi,struct cdrom_mcn *mcn);
+static int changer_reset(struct cdrom_device_info *cdi);
+static int changer_audio_ioctl(struct cdrom_device_info *cdi,unsigned int cmd,void *arg);
+static int changer_dev_ioctl(struct cdrom_device_info *cdi,unsigned int cmd,unsigned long arg);
+
+/**********************************************************************************************************************
+  Includes
+**********************************************************************************************************************/
+#include <linux/module.h>
+#include <linux/errno.h>
+#include <linux/signal.h>
+#include <linux/sched.h>
+#include <linux/mm.h>
+#include <linux/timer.h>
+#include <linux/fs.h>
+#include <linux/kernel.h>
+#include <linux/cdrom.h>
+#include <linux/ioport.h>
+#include <linux/string.h>
+#include <linux/delay.h>
+#include <linux/init.h>
+#include <linux/blk.h>
+
+#include <asm/system.h>
+#include <asm/io.h>
+#include <asm/uaccess.h>
+
+/* Enable Debug Ability 1=On, else Off. */
+/* When off then it won't include any of the debug code nor
+   any of the associated stuff like strings... */
+#define ENABLE_DEBUG_ABILITY		1
+
+/*** Message Strings (for INFO()) ***/
+const char Msg_Minor[]			= "%s: %s(): Minor %d is out of range.\n";
+const char Msg_NoSelect[]		= "%s: %s(): Device %s doesn't support select_disc... is this really a changer?\n";
+const char Msg_RegFail[]		= "%s: %s(): Cannot become a registered cdrom on device %s (register_cdrom() returned %d)\n";
+const char Msg_NoOPS[]			= "%s: %s(): Couldn't get cdi or cdi->ops is unset...\n";
+const char Msg_OpenFail[]		= "%s: %s(): Couldn't open the device %s...\n";
+const char Msg_NoSlot[]			= "%s: %s(): Couldn't select slot %d on device %s.\n";
+const char Msg_Set[]				= "%s: %s(): Setting minor=%02x device %s slot %d...\n";
+const char Msg_UnSet[]			= "%s: %s(): UN-Setting minor=%02x device %s slot %d...\n";
+const char Msg_UnSetUsed[]		= "%s: %s(): Couldn' unset minor=%02x device %s slot %d cause opencount=%d...\n";
+const char Msg_AddSelf[]		= "%s: %s(): Hmmmm eehmmm someone/thing tried to add myself to myself... wellps... that's a no go...\n";
+const char Msg_What[]			= "%s: %s(): Hi I speak version %d and NOT version %d, which you passed me, so go update your usertools!\n";
+const char Msg_What2[]			= "%s: %s(): It's the correct version but not the correct size which should've been %d, but it is %d...\n";
+const char Msg_BuffUpd[]		= "%s: %s(): Unable to update buffers...\n";
+const char Msg_GetBlk[]			= "%s: %s(): Device %s: getblk(-, %d, %d) returned NULL\n";
+const char Msg_ChildNotUsed[]	= "%s: %s(): Child %02x is unused...\n";
+const char Msg_ReqNotMine[]	= "%s: %s(): Got a request for %s which is Not one of me...\n";
+const char Msg_Header1[]		= "%s: %s (%s) by %s\n";
+const char Msg_Header2[]		= "%s: %s, %s\n";
+const char Msg_FakeFail[]		= "%s: %s(): Couldn't add a temp. fake device, use the userland program to add changers (register_cdrom()=%d)\n";
+const char Msg_MajorRegFail[]	= "%s: %s(): Unable to register major %02x! (register_blkdev() returned %d)\n";
+const char Msg_InitOk[]			= "%s: Initialized Ok...\n";
+const char Msg_ModuleFreed[]	= "%s: %s(): Module freed... Have a pleasant day.\n";
+const char Msg_Level[]			= "%s: %s(): Setting information level to %x.\n";
+
+/**********************************************************************************************************************
+  Macros
+**********************************************************************************************************************/
+#define INFO(lev,fmt,args...)		if (changer_output_level&lev) printk(fmt,KERN_INFO CHANGER_SHORT, ## args)
+#if (ENABLE_DEBUG_ABILITY==1)
+#define DEBUG(lev,fmt,args...)	if ((changer_output_level&LEVEL_DEBUG)&&(changer_output_level&lev)) printk(KERN_DEBUG CHANGER_SHORT ": " fmt, ## args)
+#else
+#define DEBUG(lev,fmt,args...)
+#endif
+
+#define CHG								changer_devs[minor]
+#define CAP(func,cap)				if (o_cdi->ops->func==NULL) CHG.cdi.mask&=~(cap)
+#define ISCAP(cap)					(CHG.cdi.mask|cap)
+#define DEVICE_LOCK()				spin_lock(&changer_majors[MAJOR(CHG.dev)].spinlock)
+#define DEVICE_UNLOCK()				spin_unlock(&changer_majors[MAJOR(CHG.dev)].spinlock)
+#define DEVICE_TRY_LOCK()			spin_trylock(&changer_majors[MAJOR(CHG.dev)].spinlock)
+#define GLOBAL_R_LOCK()				read_lock(&global_lock)
+#define GLOBAL_W_LOCK()				write_lock(&global_lock)
+#define GLOBAL_R_UNLOCK()			read_unlock(&global_lock)
+#define GLOBAL_W_UNLOCK()			write_unlock(&global_lock)
+
+/**********************************************************************************************************************
+  Module Stuff
+**********************************************************************************************************************/
+MODULE_AUTHOR(CHANGER_AUTHOR);
+MODULE_DESCRIPTION(CHANGER_FULL);
+MODULE_SUPPORTED_DEVICE("cdrom");
+
+/**********************************************************************************************************************
+  Structs and other globals.
+**********************************************************************************************************************/
+static rwlock_t global_lock;														/* The global rw lock. */
+static struct changer_dev changer_devs[CHANGER_MAX_MINOR];				/* Minor->Device mapping. */
+static int changer_sizes[CHANGER_MAX_MINOR];									/* Sizes. */
+static int changer_blksizes[CHANGER_MAX_MINOR];								/* Block Sizes. */
+static struct changer_maj changer_majors[MAX_BLKDEV];						/* Which slot is which of my minors?
+																							   For dup-checking. */
+int changer_output_level=LEVEL_INFO|LEVEL_ERR;								/* Output level. */
+
+/* capabilities (all except CDC_SELECT_DISC) */
+#define CHANGER_CAPABILITIES	CDC_CLOSE_TRAY|CDC_OPEN_TRAY|CDC_LOCK|CDC_SELECT_SPEED| \
+										CDC_MULTI_SESSION|CDC_MCN|CDC_MEDIA_CHANGED|CDC_PLAY_AUDIO| \
+										CDC_RESET|CDC_IOCTLS|CDC_DRIVE_STATUS
+
+static struct cdrom_device_ops changer_dops =
+{
+	changer_open,																		/* open */
+	changer_release,																	/* release */
+	changer_drive_status,															/* drive status */
+	changer_media_changed,															/* media changed */
+	changer_tray_move,																/* tray move */
+	changer_lock_door,																/* lock door */
+	changer_select_speed,															/* select speed */
+	NULL,																					/* select disc */
+	changer_get_last_session,														/* get last session */
+	changer_get_mcn,																	/* get universal product code */
+	changer_reset,																		/* hard reset */
+	changer_audio_ioctl,																/* audio ioctl */
+	changer_dev_ioctl,																/* device-specific ioctl */
+	CHANGER_CAPABILITIES,															/* capabilities */
+	0,																						/* number of active minor devices */
+};
+
+/**********************************************************************************************************************
+  Internal Functions
+**********************************************************************************************************************/
+/* Change the disk.
+	should be used in the following sequence:
+	8<-------------------------------------
+		DEVICE_LOCK();
+		changer_change_slot(minor);
+		<operation: read/write/info/...>
+		DEVICE_UNLOCK();
+	------------------------------------->8
+	notes: global_lock acquired.
+	results: 0=Fail,!0=Ok.
+*/
+static int changer_change_slot(minor)
+{
+	int result=0;
+	if ((minor<CHANGER_MAX_MINOR)&&(CHG.dev!=NODEV))
+	{
+		DEBUG(LEVEL_FUNC,"changer_change_slot(%02x)\n",minor);
+		blk_size[MAJOR_NR][minor]=blk_size[MAJOR(CHG.dev)][MINOR(CHG.dev)];
+		/* Find out what the current slot is. */
+		if (changer_majors[MINOR(CHG.dev)].cdi->ops->select_disc!=NULL)
+		{
+			if (changer_majors[MINOR(CHG.dev)].cdi->ops->select_disc(changer_majors[MINOR(CHG.dev)].cdi,CDSL_CURRENT)!=CHG.slot)
+			{
+				/* Change slot, cause current!=wanted. */
+				if (changer_majors[MINOR(CHG.dev)].cdi->ops->select_disc(changer_majors[MINOR(CHG.dev)].cdi,CHG.slot)==CHG.slot)
+				{
+					/* Invalidate the buffers. */
+					invalidate_buffers(CHG.dev);
+					result=1;
+				}
+				else INFO(LEVEL_ERR,Msg_NoSlot,"changer_change_slot",CHG.slot,bdevname(CHG.dev));
+			}
+			else result=1;
+		}
+		/* Should never happen, as it gets checked in changer_set() */
+		else INFO(LEVEL_ERR,Msg_NoSelect,"changer_change_slot",bdevname(CHG.dev));
+	}
+	/* This should never happen as it should have been checked by the code calling this function. */
+	else INFO(LEVEL_ERR,Msg_Minor,"changer_change_slot",minor);
+	return(result);
+}
+
+/* NO locks acquired. */
+static int changer_set(struct cdrom_device_info *cdi,struct changer_set *set)
+{
+	int minor=MINOR(cdi->dev),result=0,ret,maj,min;
+	struct cdrom_device_info *o_cdi=NULL;
+
+	GLOBAL_W_LOCK();
+
+	/* We want to be sure of this. */
+	if (minor<CHANGER_MAX_MINOR)
+	{
+		/* if set is supplied it must be my version and the correct size, no set is ok too... */
+		if (((set)&&(set->version==CHANGER_VERSION_SET)&&(sizeof(struct changer_set)==set->size))||(set==NULL))
+		{
+			/* Was it used before? */
+			if (CHG.dev!=NODEV)
+			{
+				if (CHG.opencount==0)
+				{
+					/* Let's close it */
+					maj=MAJOR(CHG.dev);
+					min=MINOR(CHG.dev);
+					INFO(LEVEL_INFO,Msg_UnSet,"changer_set",minor,bdevname(CHG.dev),CHG.slot);
+					/* Close/Release the device when opencount reaches 0. */
+					if (changer_majors[maj].opencount==0)
+					{
+						DEBUG(LEVEL_INFO,"changer_set(): Closing device %s...(opencount==0)\n",bdevname(CHG.dev));
+						changer_wrap_release(changer_majors[MINOR(CHG.dev)].cdi);
+					}
+					/* Unregister MAJOR_NR,minor as cdrom. */
+					unregister_cdrom(&CHG.cdi);
+					changer_majors[maj].minor[min]=NODEV;
+					changer_majors[maj].opencount--;
+					CHG.dev=NODEV;
+					result=0;
+				}
+				else
+				{
+					INFO(LEVEL_INFO,Msg_UnSetUsed,"changer_set",minor,bdevname(CHG.dev),CHG.slot,CHG.opencount);
+					result=-EALREADY;
+				}
+			}
+			if ((CHG.dev==NODEV)&&(set))
+			{
+				result=-EINVAL;
+				maj=set->major;
+				if (maj!=MAJOR_NR)
+				{
+					min=set->minor;
+					/* Copy attributes / Adapt Settings. */
+					CHG.dev=MKDEV(set->major,set->minor);
+					CHG.opencount=0;
+					CHG.slot=set->slot;
+					o_cdi=cdi;
+					while ((o_cdi!=NULL)&&(o_cdi->dev!=CHG.dev)) o_cdi=o_cdi->next;
+					if ((o_cdi)&&(o_cdi->ops))
+					{
+						/* Cache the cdi. */
+						changer_majors[MINOR(CHG.dev)].cdi=o_cdi;
+	
+						/* Fill in specific dops. */
+						CHG.cdi.ops=&changer_dops;
+						CHG.cdi.handle=NULL;
+						CHG.cdi.dev = MKDEV(MAJOR_NR,minor);
+						CHG.cdi.mask=CHANGER_CAPABILITIES;
+						CHG.cdi.speed=o_cdi->speed;
+						CHG.cdi.capacity=1;
+						CHG.cdi.options=o_cdi->options;
+						CHG.cdi.mc_flags=0;
+						CHG.cdi.use_count=0;
+	
+						/* Disable capabilities the drive doesn't have functions for. */
+						CAP(drive_status,CDC_DRIVE_STATUS);
+						CAP(media_changed,CDC_MEDIA_CHANGED);
+						CAP(tray_move,CDC_OPEN_TRAY|CDC_CLOSE_TRAY);
+						CAP(lock_door,CDC_LOCK);
+						CAP(select_speed,CDC_SELECT_SPEED);
+						CAP(select_disc,CDC_SELECT_DISC);
+						CAP(get_last_session,CDC_MULTI_SESSION);
+						CAP(get_mcn,CDC_MCN);
+						CAP(reset,CDC_RESET);
+						CAP(audio_ioctl,CDC_PLAY_AUDIO);
+
+						/* Check if it really can select discs... */
+						if (ISCAP(CDC_SELECT_DISC))
+						{
+							strncpy(CHG.cdi.name,set->name,(CHANGER_NAME_LEN-1));
+							/* Open the child device. */
+							if (((changer_majors[maj].opencount)>0)||
+									(((changer_majors[maj].opencount)==0)&&(result=changer_wrap_open(cdi)==0)))
+							{
+								changer_majors[maj].opencount++;
+								changer_majors[maj].minor[min]=minor;
+								/* Register MAJOR_NR,minor as cdrom. */
+								if ((ret=register_cdrom(&CHG.cdi))==0)
+								{
+									result=0;
+									INFO(LEVEL_INFO,Msg_Set,"changer_set",minor,bdevname(CHG.dev),set->slot);
+									blk_size[MAJOR_NR][minor]=blk_size[MAJOR(CHG.dev)][MINOR(CHG.dev)];
+								}
+								else
+								{
+									INFO(LEVEL_ERR,Msg_RegFail,"changer_set",bdevname(CHG.cdi.dev),ret);
+									unregister_cdrom(&CHG.cdi);
+									CHG.dev=NODEV;
+									result=-EIO;
+								}
+							}
+							else
+							{
+								INFO(LEVEL_ERR,Msg_OpenFail,"changer_set",bdevname(MKDEV(set->major,set->major)));
+								CHG.dev=NODEV;
+								result=-EINVAL;
+							}
+						}
+						else
+						{
+							INFO(LEVEL_ERR,Msg_NoSelect,"changer_set",bdevname(MKDEV(set->major,set->major)));
+							result=-EINVAL;
+						}
+					}
+					else
+					{
+						INFO(LEVEL_ERR,Msg_NoOPS,"changer_set");
+						CHG.dev=NODEV;
+						result=-EINVAL;
+					}
+				}
+				else
+				{
+					INFO(LEVEL_ERR,Msg_AddSelf,"changer_set");
+					result=-EINVAL;
+				}
+			}
+			else result=-EINVAL;
+		}
+		else
+		{
+			if (set->version!=CHANGER_VERSION_SET) INFO(LEVEL_ERR,Msg_What,"changer_set",CHANGER_VERSION_SET,set->version);
+			else INFO(LEVEL_ERR,Msg_What2,"changer_set",sizeof(set),set->size);
+			result=-EINVAL;
+		}
+	}
+	else INFO(LEVEL_ERR,Msg_Minor,"changer_set",minor);
+	GLOBAL_W_UNLOCK();
+	return(result);
+}
+
+/**********************************************************************************************************************
+  The actual wrapper functions.
+**********************************************************************************************************************/
+/* Simply gets the kdev_t from the child-table and sets the flag. */
+/* TODO: ACTUALLY OPEN THE DEVICE, this is not done yet... <grin> */
+/* note: called with global write lock acquired */
+static int changer_wrap_open(struct cdrom_device_info *cdi)
+{
+	int				minor=MINOR(cdi->dev),ret=-EIO;
+
+	DEBUG(LEVEL_FUNC,"changer_wrap_open()\n");
+	if ((minor<CHANGER_MAX_MINOR)&&(CHG.dev!=NODEV))
+	{
+		blk_size[MAJOR_NR][minor]=blk_size[MAJOR(CHG.dev)][MINOR(CHG.dev)];
+
+		changer_majors[MAJOR(CHG.dev)].file=get_empty_filp();
+		if (changer_majors[MAJOR(CHG.dev)].file)
+		{
+			memset(&changer_majors[MAJOR(CHG.dev)].inode,0,sizeof(changer_majors[MAJOR(CHG.dev)].inode));
+			memset(&changer_majors[MAJOR(CHG.dev)].dentry,0,sizeof(changer_majors[MAJOR(CHG.dev)].dentry));
+			changer_majors[MAJOR(CHG.dev)].inode.i_rdev=CHG.dev;
+			changer_majors[MAJOR(CHG.dev)].file->f_mode=1;	/* read only */
+			changer_majors[MAJOR(CHG.dev)].file->f_dentry=&changer_majors[MAJOR(CHG.dev)].dentry;
+			changer_majors[MAJOR(CHG.dev)].file->f_flags=O_NONBLOCK;
+			changer_majors[MAJOR(CHG.dev)].dentry.d_inode=&changer_majors[MAJOR(CHG.dev)].inode;
+			/* Adds support for dynamic module loading */
+			ret=blkdev_open(&changer_majors[MAJOR(CHG.dev)].inode,changer_majors[MAJOR(CHG.dev)].file);
+			if (!ret)
+			{
+				/*
+				check_disk_change(CHG.dev);
+				set_device_ro(CHG.dev,1);
+				*/
+			}
+			else put_filp(changer_majors[MAJOR(CHG.dev)].file);
+		}
+		else ret=-ENFILE;
+	}
+	else INFO(LEVEL_ERR,Msg_Minor,"changer_wrap_open",minor);
+	return(ret);
+}
+
+/* Simply gets the kdev_t from the child-table, sets the flag and closes it. */
+/* Logs show that it gets unlocked etc. */
+/* note: called with global write lock acquired */
+static void changer_wrap_release(struct cdrom_device_info *cdi)
+{
+	int				minor=MINOR(cdi->dev);
+
+	DEBUG(LEVEL_FUNC,"changer_wrap_release()\n");
+	if ((minor<CHANGER_MAX_MINOR)&&(CHG.dev!=NODEV))
+	{
+		blkdev_release(changer_majors[MAJOR(CHG.dev)].file->f_dentry->d_inode);
+		dput(changer_majors[MAJOR(CHG.dev)].file->f_dentry);
+		put_filp(changer_majors[MAJOR(CHG.dev)].file);
+		invalidate_buffers(CHG.dev);
+	}
+	else INFO(LEVEL_ERR,Msg_Minor,"changer_wrap_release",minor);
+}
+
+/* TODO:
+		- optimization!
+			- queue splitting per changer device.
+				= What happens if the queues are split (and thus removed from the actual request list?)
+				  does this function still get called to clean up its own queues or do I have to add
+				  a scsi-alike patch for that... ?
+				  = (yep answer to my own question) I'll have to look at inc/linux/tqueue.h :)
+			- request aging+reordering per queue
+				= request should not stay into the requestlist to long either...
+				  so if the queue gets longer than 'n' entries don't reorder and
+				  let the queue run clean first. I'll make a flag in the queue
+				  header, which will contain the number of entries or negative entries for cleaning.
+				  When it has had the first 'n' entries cleaned it can reorder the rest... which
+				  were added ordered at the end of the list.
+				  example for reordering+aging, with maxage=3, a queue would could like:
+				  312,645,798,newones
+				  and as the list is done from front to end it will be cleaned automatically.
+			attempt_merge() in ll_rw_block.c
+		- Take a look at include/linux/tqueue.h for queue'ing!
+		- sanity checks.
+		- "clean" error messages.
+*/
+static void do_changer_request(void)
+{
+	struct request			*req;
+	int						minor,ok=1,blksize,block,offset,len,size;
+	char						*dest;
+	struct buffer_head	*bh;
+
+	GLOBAL_R_LOCK();
+	while ((CURRENT)&&(ok!=-1))
+	{
+		ok=1;
+
+		/* Get current request */
+		req=CURRENT;
+		/* Take it off the list. */
+		CURRENT=CURRENT->next;
+
+		/* It should be ours. */
+		if (MAJOR(req->rq_dev)==MAJOR_NR)
+		{
+			minor=MINOR(req->rq_dev);
+			/* Is it a used minor? */
+			if ((minor<CHANGER_MAX_MINOR)&&(CHG.dev!=NODEV))
+			{
+				DEBUG(LEVEL_FUNC,"changer_request(): The request is for minor %02x child device %s.\n",minor,bdevname(CHG.dev));
+
+				/* Calculate block sizes. */
+				blksize=BLOCK_SIZE;
+				if (blksize_size[MAJOR(CHG.dev)])
+				{
+					blksize=blksize_size[MAJOR(CHG.dev)][MINOR(CHG.dev)];
+					if (!blksize) blksize=BLOCK_SIZE;
+				}
+				dest=req->buffer;
+				if (blksize<512)
+				{
+					block=req->sector*(512/blksize);
+					offset=0;
+				}
+				else
+				{
+					block=req->sector/(blksize>>9);
+					offset=(req->sector%(blksize>>9))<<9;
+				}
+				if (offset>blksize)
+				{
+					block++;
+					offset-=blksize;
+				}
+				len=req->current_nr_sectors<<9;
+				DEBUG(LEVEL_XS,"changer_request(): Determined sector=%d, len=%d, offset=%d, block=%d, blksize=%d\n",(int)req->sector,len,offset,block,blksize);
+
+				/* Unlock the request so others (the child-device for example) can proceed. */
+				spin_unlock_irq(&io_request_lock);
+				/* Try and lock the device. */
+				if (DEVICE_TRY_LOCK())
+				{
+					/* Change to correct disc. */
+					if (changer_change_slot(minor))
+					{
+						/* Collect all the pieces. */
+						while (len>0)
+						{
+							size=blksize-offset;
+							if (size>len) size=len;
+							if ((bh=getblk(CHG.dev,block,blksize)))
+							{
+								DEBUG(LEVEL_XS,"changer_request(): getblk() OK\n");
+								if (!buffer_uptodate(bh)&&((req->cmd==READ)||(offset||(len<blksize))))
+								{
+									DEBUG(LEVEL_XS,"changer_request(): Calling ll_rw_block().\n");
+									ll_rw_block(READ,1,&bh);
+									wait_on_buffer(bh);
+									if (!buffer_uptodate(bh))
+									{
+										INFO(LEVEL_ERR,Msg_BuffUpd,"changer_request");
+										ok=0;
+									}
+								}
+								else DEBUG(LEVEL_XS,"changer_request(): Buffers were up-to-date.\n");
+								/* copy the read data to the buffer */
+								if (ok) memcpy(dest,bh->b_data+offset,BLOCK_SIZE);
+								/* Release the buffer head */
+								brelse(bh);
+							}
+							else
+							{
+								INFO(LEVEL_ERR,Msg_GetBlk,"changer_request",bdevname(CHG.dev),block,blksize);
+								ok=0;
+							}
+							dest+=size;
+							len-=size;
+							offset=0;
+							block++;
+						}
+					}
+					/* All done so unlock the disc. */
+					DEVICE_UNLOCK();
+				}
+				else ok=-1; /* Couldn't get the lock, so don't end this request. */
+				/* Re-lock the request list. */
+				spin_lock_irq(&io_request_lock);
+			}
+			else
+			{
+				INFO(LEVEL_ERR,Msg_ChildNotUsed,"changer_request",minor);
+				ok=0;
+			}
+		}
+		else
+		{
+			INFO(LEVEL_ERR,Msg_ReqNotMine,"changer_request",req->rq_dev);
+			ok=0;
+		}
+		/* Put it back into the list. */
+		req->next=CURRENT;
+		CURRENT=req;
+		if (ok!=-1)
+		{
+			DEBUG(LEVEL_XS,"Ending the request with %d (1=ok,0=eeks)\n",ok);
+			end_request(ok);
+		}
+	}
+	GLOBAL_R_UNLOCK();
+}
+
+/**********************************************************************************************************************
+  Initialization and other relevant wrappers.
+**********************************************************************************************************************/
+#ifndef MODULE
+__initfunc(static void changer_setup(char *str, int *ints))
+{
+	DEBUG(LEVEL_FUNC,"changer_setup()\n");
+}
+#endif
+
+__initfunc(static void changer_cleanup(void))
+{
+	int minor;
+	struct cdrom_device_info cdi;
+
+	DEBUG(LEVEL_FUNC,"changer_cleanup()\n");
+	for (minor=0;minor<CHANGER_MAX_MINOR;minor++)
+	{
+		cdi.dev=MKDEV(MAJOR_NR,minor);
+		changer_set(&cdi,NULL);
+	}
+	unregister_blkdev(MAJOR_NR,c_short);
+}
+
+/* Test if all OK (Called at boot/module-init time). */
+__initfunc(static int changer_init(void))
+{
+	int minor=0,result=0,ret,slot,i;
+	struct cdrom_device_info fake_cdi = {&changer_dops,0,0,0,0,0,0,0,0,0,"ChangerFake"},*cdi;
+	struct changer_set set = {CHANGER_VERSION_SET,sizeof(struct changer_set),0,0,0,""};
+
+	DEBUG(LEVEL_FUNC,"changer_init()\n");
+	INFO(LEVEL_ANY,Msg_Header1,c_full,c_date,c_by);
+	INFO(LEVEL_ANY,Msg_Header2,c_www,c_list);
+
+	/* Initialize data parts. */
+	memset(&changer_devs,0,sizeof(changer_devs));
+	memset(&changer_sizes,0,sizeof(changer_sizes));
+	memset(&changer_blksizes,0,sizeof(changer_blksizes));
+	memset(&changer_majors,0,sizeof(changer_majors));
+
+	DEBUG(LEVEL_INFO,"Initializing spinlocks...\n");
+
+	/* Initialize all the device spinlocks. */
+	for (i=0;i<MAX_BLKDEV;i++) changer_majors[i].spinlock=SPIN_LOCK_UNLOCKED;
+	/* Initialize global spinlock. */
+	global_lock=RW_LOCK_UNLOCKED;
+
+	DEBUG(LEVEL_INFO,"Registering the block device...\n");
+
+	if (!(ret=register_blkdev(MAJOR_NR,c_short,&cdrom_fops)))
+	{
+		/* The settings below are really splattered
+			around the kernel, wouldn't it be nicer to have
+			them in one struct? */
+		blk_dev[MAJOR_NR].request_fn=DEVICE_REQUEST;
+		blk_dev[MAJOR_NR].current_request=NULL;
+		blk_size[MAJOR_NR]=changer_sizes;
+		blksize_size[MAJOR_NR]=changer_blksizes;
+		read_ahead[MAJOR_NR]=INT_MAX;
+		
+		DEBUG(LEVEL_INFO,"Going for the registration of the fake device...\n");
+
+		/* Trick Time */
+		/* Temporary add a fake cdrom drive. */
+		/* Simply to get the cdi list entries. */
+		fake_cdi.dev=MKDEV(MAJOR_NR,CHANGER_MAX_MINOR-1);
+		if ((ret=register_cdrom(&fake_cdi))==0)
+		{
+			cdi=fake_cdi.next;
+			/* Travel list and add devices. */
+			while (cdi!=NULL)
+			{
+				if (cdi->capacity>1)
+				{
+					set.major=MAJOR(cdi->dev);
+					set.minor=MINOR(cdi->dev);
+					for (slot=0;slot<cdi->capacity;slot++)
+					{
+						set.slot=slot;
+						/* WARNING: Length limits, it's overflowable currently with large numbers. */
+						sprintf(set.name,CHANGER_DEVNAME"%d",minor);
+						fake_cdi.dev=MKDEV(MAJOR_NR,minor);
+						/* Add cdrom device. */
+						DEBUG(LEVEL_INFO,"Adding minor=%02x device %s slot %d...\n",minor,bdevname(MKDEV(set.major,set.minor)),slot);
+						if (changer_set(&fake_cdi,&set)==0) minor++;
+						/* else failed... */
+					}
+				}
+				/* Next... */
+				cdi=cdi->next;
+			}
+		}
+		else
+		{
+			/* Wellps.. it ain't that important... there is always the userland proggy... */
+			INFO(LEVEL_ERR,Msg_FakeFail,"initfunc",ret);
+		}
+		/* And unregister the fake device... */
+		fake_cdi.dev=MKDEV(MAJOR_NR,CHANGER_MAX_MINOR-1);
+		unregister_cdrom(&fake_cdi);
+	}
+	else
+	{
+		INFO(LEVEL_ERR,Msg_MajorRegFail,"initfunc",MAJOR_NR,ret);
+		result=-EIO;
+	}
+	if (result==0)	INFO(LEVEL_INFO,Msg_InitOk);
+	else changer_cleanup();
+	return(result);
+}
+
+/**********************************************************************************************************************
+  The CdRom Wrapper Functions
+***********************************************************************************************************************
+  Most of the parts of these functions are based on the fact that they "ask" the real driver to perform the function.
+**********************************************************************************************************************/
+/* Open() the device special file. */
+static int changer_open(struct cdrom_device_info *cdi,int purpose)
+{
+	int minor=MINOR(cdi->dev),result=0;
+	DEBUG(LEVEL_FUNC,"changer_open(%02x:purpose=%d)\n",minor,purpose);
+	/* Open actual driver is done on changer_set(). */
+	GLOBAL_R_LOCK();
+	if ((minor<CHANGER_MAX_MINOR)&&(CHG.dev!=NODEV))
+	{
+		CHG.opencount++;
+#ifdef MODULE
+		MOD_INC_USE_COUNT;
+#endif
+	}
+	else result=-EINVAL;
+	GLOBAL_R_UNLOCK();
+	return(result);				/* 0 = Success, <0 = Error */
+}
+
+/* Release() - Close device. */
+static void changer_release(struct cdrom_device_info *cdi)
+{
+	int minor=MINOR(cdi->dev);
+	DEBUG(LEVEL_FUNC,"changer_release(%02x)\n",minor);
+	/* Close actual driver is done on changer_set(NODEV). */
+	GLOBAL_R_LOCK();
+	if ((minor<CHANGER_MAX_MINOR)&&(CHG.dev!=NODEV))
+	{
+#ifdef MODULE
+		MOD_DEC_USE_COUNT;
+#endif
+		CHG.opencount--;
+	}
+	GLOBAL_R_UNLOCK();
+}
+
+/* Status() - Get drive status. */
+static int changer_drive_status(struct cdrom_device_info *cdi,int slot_nr)
+{
+	int minor=MINOR(cdi->dev),result=-EIO;
+	DEBUG(LEVEL_FUNC,"changer_drive_status(%02x:slot=%d)\n",minor,slot_nr);
+	GLOBAL_R_LOCK();
+	if ((minor<CHANGER_MAX_MINOR)&&(CHG.dev!=NODEV))
+	{
+		DEVICE_LOCK();
+		if (changer_change_slot(minor))
+		{
+			result=changer_majors[MINOR(CHG.dev)].cdi->ops->drive_status(changer_majors[MINOR(CHG.dev)].cdi,CHG.slot);
+		}
+		else result=-EINVAL;
+		DEVICE_UNLOCK();
+	}
+	else result=-EINVAL;
+	GLOBAL_R_UNLOCK();
+	return(result);		/* CDS_NO_INFO | CDS_NO_DISC | CDS_TRAY_OPEN | CDS_DRIVE_NOT_READY | CDS_DISC_OK */
+}
+
+/* Media_Changed() - Check Media Changed Status */
+static int changer_media_changed(struct cdrom_device_info *cdi,int disc_nr)
+{
+   int minor=MINOR(cdi->dev),result=0;
+	DEBUG(LEVEL_FUNC,"changer_media_changed(%02x,disc=%d)\n",minor,disc_nr);
+	GLOBAL_R_LOCK();
+	if ((minor<CHANGER_MAX_MINOR)&&(CHG.dev!=NODEV))
+	{
+		DEVICE_LOCK();
+		if (changer_change_slot(minor))
+		{
+			result=changer_majors[MINOR(CHG.dev)].cdi->ops->media_changed(changer_majors[MINOR(CHG.dev)].cdi,CHG.slot);
+		}
+		else result=-EINVAL;
+		DEVICE_UNLOCK();
+	}
+	else result=-EINVAL;
+	GLOBAL_R_LOCK();
+   return(result);		/* 0 = NOT Changed, 1 = Changed */
+}
+
+/* MoveTray() - Move the tray: open (position=0), or close (position=1). */
+static int changer_tray_move(struct cdrom_device_info *cdi,int position)
+{
+	int minor=MINOR(cdi->dev),result=-EINVAL;
+	DEBUG(LEVEL_FUNC,"changer_tray_move(%02x:position=%d)\n",minor,position);
+	GLOBAL_R_LOCK();
+	if ((minor<CHANGER_MAX_MINOR)&&(CHG.dev!=NODEV))
+	{
+		DEVICE_LOCK();
+		if (changer_change_slot(minor))
+		{
+			result=changer_majors[MINOR(CHG.dev)].cdi->ops->tray_move(changer_majors[MINOR(CHG.dev)].cdi,position);
+		}
+		else result=-EINVAL;
+		DEVICE_UNLOCK();
+	}
+	else result=-EINVAL;
+	GLOBAL_R_UNLOCK();
+	return(result);		/* 0 = Ok its there now, 1 = Fail, it won't. */
+}
+
+/* LockDoor() - Lock the door: unlock (lock=0), or locked (lock=1). */
+static int changer_lock_door(struct cdrom_device_info *cdi,int lock)
+{
+	int minor=MINOR(cdi->dev),result=-EINVAL;
+	DEBUG(LEVEL_ANY,"changer_lock_door(%02x:lock=%d)\n",minor,lock);
+	GLOBAL_R_LOCK();
+	if ((minor<CHANGER_MAX_MINOR)&&(CHG.dev!=NODEV))
+	{
+		DEVICE_LOCK();
+		if (changer_change_slot(minor))
+		{
+			result=changer_majors[MINOR(CHG.dev)].cdi->ops->lock_door(changer_majors[MINOR(CHG.dev)].cdi,lock);
+		}
+		else result=-EINVAL;
+		DEVICE_UNLOCK();
+	}
+	else result=-EINVAL;
+	GLOBAL_R_LOCK();
+	return(result);		/* 0 = Ok it is, 1 = Fail, it won't. */
+}
+
+/* SelectSpeed() - Select the speed. */
+static int changer_select_speed(struct cdrom_device_info *cdi,int speed)
+{
+	int minor=MINOR(cdi->dev),result=-EINVAL;
+	DEBUG(LEVEL_FUNC,"changer_select_speed(%02x:speed=%d)\n",minor,speed);
+	GLOBAL_R_LOCK();
+	if ((minor<CHANGER_MAX_MINOR)&&(CHG.dev!=NODEV))
+	{
+		DEVICE_LOCK();
+		if (changer_change_slot(minor))
+		{
+			result=changer_majors[MINOR(CHG.dev)].cdi->ops->select_speed(changer_majors[MINOR(CHG.dev)].cdi,speed);
+		}
+		else result=-EINVAL;
+		DEVICE_UNLOCK();
+	}
+	else result=-EINVAL;
+	GLOBAL_R_UNLOCK();
+	return(result);		/* >=0 = Ok, <0 = Failed. */
+}
+
+/* GetLastSession() - Get last session. */
+static int changer_get_last_session(struct cdrom_device_info *cdi,struct cdrom_multisession *ms_info)
+{
+	int minor=MINOR(cdi->dev),result=-EINVAL;
+	DEBUG(LEVEL_FUNC,"changer_get_last_session(%02x)\n",minor);
+	GLOBAL_R_LOCK();
+	if ((minor<CHANGER_MAX_MINOR)&&(CHG.dev!=NODEV))
+	{
+		DEVICE_LOCK();
+		if (changer_change_slot(minor))
+		{
+			result=changer_majors[MINOR(CHG.dev)].cdi->ops->get_last_session(changer_majors[MINOR(CHG.dev)].cdi,ms_info);
+		}
+		else result=-EINVAL;
+		DEVICE_UNLOCK();
+	}
+	else result=-EINVAL;
+	GLOBAL_R_UNLOCK();
+	return(result);		/* 0 = Success, ??Else = Error?? <-- Not documented!! */
+}
+
+/* GetMCN() - Get Media Catalog Number (MCN) / Universal Product Code (UPN). */
+static int changer_get_mcn(struct cdrom_device_info *cdi,struct cdrom_mcn *mcn)
+{
+	int minor=MINOR(cdi->dev),result=0;
+	DEBUG(LEVEL_FUNC,"changer_get_mcn(%02x)\n",minor);
+	GLOBAL_R_LOCK();
+	if ((minor<CHANGER_MAX_MINOR)&&(CHG.dev!=NODEV))
+	{
+		DEVICE_LOCK();
+		if (changer_change_slot(minor))
+		{
+			result=changer_majors[MINOR(CHG.dev)].cdi->ops->get_mcn(changer_majors[MINOR(CHG.dev)].cdi,mcn);
+		}
+		else result=-EINVAL;
+		DEVICE_UNLOCK();
+	}
+	else result=-EINVAL;
+	GLOBAL_R_UNLOCK();
+	return(result);			/* ?? 0 = Fail, char *var[14]="MCNMCNMCNMCNM\0"; ?? <-- Not documented!!  */
+}
+
+/* Reset() - Reset. */
+static int changer_reset(struct cdrom_device_info *cdi)
+{
+	int minor=MINOR(cdi->dev),result=-EINVAL;
+	DEBUG(LEVEL_FUNC,"changer_reset(%02x)\n",minor);
+	GLOBAL_R_LOCK();
+	if ((minor<CHANGER_MAX_MINOR)&&(CHG.dev!=NODEV))
+	{
+		DEVICE_LOCK();
+		if (changer_change_slot(minor))
+		{
+			result=changer_majors[MINOR(CHG.dev)].cdi->ops->reset(changer_majors[MINOR(CHG.dev)].cdi);
+		}
+		else result=-EINVAL;
+		DEVICE_UNLOCK();
+	}
+	else result=-EINVAL;
+	GLOBAL_R_UNLOCK();
+	return(result);		/* 0 = Success. */
+}
+
+/* AudioIOCTL() - Audio Calls. */
+static int changer_audio_ioctl(struct cdrom_device_info *cdi,unsigned int cmd,void *arg)
+{
+	int minor=MINOR(cdi->dev),result=ENOSYS;
+	DEBUG(LEVEL_FUNC,"changer_audio_ioctl(%02x:cmd=%x)\n",minor,cmd);
+	GLOBAL_R_LOCK();
+	if ((minor<CHANGER_MAX_MINOR)&&(CHG.dev!=NODEV))
+	{
+		DEVICE_LOCK();
+		if (changer_change_slot(minor))
+		{
+			result=changer_majors[MINOR(CHG.dev)].cdi->ops->audio_ioctl(changer_majors[MINOR(CHG.dev)].cdi,cmd,arg);
+		}
+		else result=-EINVAL;
+		DEVICE_UNLOCK();
+	}
+	else result=-EINVAL;
+	GLOBAL_R_UNLOCK();
+	return(result);		/* 0 = Success, ENOSYS = Not implemented, other = error. */
+}
+
+/* DevIOCTL() - Device Calls. */
+static int changer_dev_ioctl(struct cdrom_device_info *cdi,unsigned int cmd,unsigned long arg)
+{
+	int minor=MINOR(cdi->dev),result=-EINVAL;
+	DEBUG(LEVEL_FUNC,"changer_dev_ioctl(%02x:cmd=%x)\n",minor,cmd);
+
+	switch (cmd)
+	{
+		case CHANGER_SET:
+								/* Let only root (or equivalent) do this function. */
+								if (capable(CAP_SYS_ADMIN))
+								{
+									if (minor<CHANGER_MAX_MINOR)
+									{
+										struct changer_set set;
+										if (copy_from_user(&set,(struct changer_set *)arg,sizeof(set))) result=-EFAULT;
+										else result=changer_set(cdi,&set);
+									}
+									else result=-EINVAL;
+								}
+								else result=-EACCES;
+								break;
+		case CHANGER_GET:
+								if	(minor<CHANGER_MAX_MINOR)
+								{
+									struct changer_set set;
+									if (copy_from_user(&set,(struct changer_set *)arg,sizeof(set))) result=-EFAULT;
+									else
+									{
+										if (set.version==CHANGER_VERSION_SET)
+										{
+											if (set.size==sizeof(set))
+											{
+												set.major=MAJOR(CHG.dev);
+												set.minor=MINOR(CHG.dev);
+												set.slot=CHG.slot;
+												strncpy(set.name,CHG.cdi.name,(CHANGER_NAME_LEN-1));
+												if (copy_to_user((struct changer_set *)arg,&set,sizeof(set))) result=-EFAULT;
+												else result=0;
+											}
+											else
+											{
+												INFO(LEVEL_ERR,Msg_What2,"changer_dev_ioctl:changer_get",sizeof(set),set.size);
+												result=-EINVAL;
+											}
+										}
+										else
+										{
+											INFO(LEVEL_ERR,Msg_What,"changer_dev_ioctl:changer_get",CHANGER_VERSION_SET,set.version);
+											result=-EINVAL;
+										}
+									}
+								}
+								else result=-EINVAL;
+								break;
+		case CHANGER_SET_LEVEL:
+								/* Let only root (or equivalent) do this function. */
+								if (capable(CAP_SYS_ADMIN))
+								{
+									INFO(LEVEL_ANY,Msg_Level,"changer_dev_ioctl:changer_set_level",arg);
+									changer_output_level=arg;
+								}
+								else result=-EACCES;
+								break;
+		default:				if ((minor<CHANGER_MAX_MINOR)&&(CHG.dev!=NODEV))
+								{
+									GLOBAL_R_LOCK();
+									DEVICE_LOCK();
+									if (changer_change_slot(minor))
+									{
+										result=changer_majors[MINOR(CHG.dev)].cdi->ops->dev_ioctl(changer_majors[MINOR(CHG.dev)].cdi,cmd,arg);
+									}
+									else result=-EINVAL;
+									DEVICE_UNLOCK();
+									GLOBAL_R_UNLOCK();
+								}
+								else result=-EINVAL;
+	}
+	return(result);
+}
+
+/**********************************************************************************************************************
+  Modules Stuff
+**********************************************************************************************************************/
+#ifdef MODULE
+int init_module(void)
+{
+	DEBUG(LEVEL_FUNC,"init_module()\n");
+	return(changer_init());
+}
+
+void cleanup_module(void)
+{
+	DEBUG(LEVEL_FUNC,"cleanup_module()\n");
+	changer_cleanup();
+	INFO(LEVEL_INFO,Msg_ModuleFreed,"cleanup_module");
+}
+#endif MODULE
+
diff -u --new-file --recursive linux-229/drivers/block/ll_rw_blk.c linux-229-changer/drivers/block/ll_rw_blk.c
--- linux-229/drivers/block/ll_rw_blk.c	Fri Mar 12 08:20:14 1999
+++ linux-229-changer/drivers/block/ll_rw_blk.c	Wed May 19 00:25:31 1999
@@ -443,8 +443,9 @@
 
 /* look for a free request. */
        /* Loop uses two requests, 1 for loop and 1 for the real device.
-        * Cut max_req in half to avoid running out and deadlocking. */
-	 if ((major == LOOP_MAJOR) || (major == NBD_MAJOR))
+        * Cut max_req in half to avoid running out and deadlocking.
+		  * This is also true for nbd and changer device. */
+	 if ((major == LOOP_MAJOR) || (major == NBD_MAJOR) || (major == CHANGER_MAJOR))
 	     max_req >>= 1;
 
 	/*
@@ -459,9 +460,10 @@
 	spin_lock_irqsave(&io_request_lock,flags);
 	req = *get_queue(bh->b_rdev);
 	if (!req) {
-		/* MD and loop can't handle plugging without deadlocking */
+		/* MD, loop and changer can't handle plugging without deadlocking */
 		if (major != MD_MAJOR && major != LOOP_MAJOR && 
-		    major != DDV_MAJOR && major != NBD_MAJOR)
+		    major != DDV_MAJOR && major != NBD_MAJOR &&
+			 major != CHANGER_MAJOR)
 			plug_device(blk_dev + major); /* is atomic */
 	} else switch (major) {
 	     case IDE0_MAJOR:	/* same as HD_MAJOR */
@@ -828,6 +830,9 @@
 #endif
 #ifdef CONFIG_BLK_DEV_NBD
 	nbd_init();
+#endif
+#ifdef CONFIG_CHANGER
+	changer_init();
 #endif
 	return 0;
 };
diff -u --new-file --recursive linux-229/drivers/cdrom/Makefile linux-229-changer/drivers/cdrom/Makefile
--- linux-229/drivers/cdrom/Makefile	Fri Aug 21 00:17:06 1998
+++ linux-229-changer/drivers/cdrom/Makefile	Wed May 19 00:25:31 1999
@@ -24,6 +24,7 @@
 # Each configuration option enables a list of files.
 
 obj-$(CONFIG_BLK_DEV_IDECD)	+=              cdrom.o
+obj-$(CONFIG_CHANGER)		+= cdrom.o
 obj-$(CONFIG_BLK_DEV_SR)	+=              cdrom.o
 obj-$(CONFIG_PARIDE_PCD)	+=		cdrom.o
 
diff -u --new-file --recursive linux-229/include/linux/blk.h linux-229-changer/include/linux/blk.h
--- linux-229/include/linux/blk.h	Tue May 11 19:36:25 1999
+++ linux-229-changer/include/linux/blk.h	Wed May 19 01:37:54 1999
@@ -63,6 +63,7 @@
 extern int ez_init(void);
 extern int bpcd_init(void);
 extern int ps2esdi_init(void);
+extern int changer_init(void);
 
 extern void set_device_ro(kdev_t dev,int flag);
 void add_blkdev_randomness(int major);
@@ -354,6 +355,14 @@
 #define DEVICE_REQUEST do_nbd_request
 #define DEVICE_NR(device) (MINOR(device))
 #define DEVICE_ON(device) 
+#define DEVICE_OFF(device)
+
+#elif (MAJOR_NR == CHANGER_MAJOR)
+
+#define DEVICE_NAME "changer"
+#define DEVICE_REQUEST do_changer_request
+#define DEVICE_NR(device) (MINOR(device))
+#define DEVICE_ON(device)
 #define DEVICE_OFF(device)
 
 #endif /* MAJOR_NR == whatever */
diff -u --new-file --recursive linux-229/include/linux/changer.h linux-229-changer/include/linux/changer.h
--- linux-229/include/linux/changer.h	Thu Jan  1 01:00:00 1970
+++ linux-229-changer/include/linux/changer.h	Wed May 19 01:41:48 1999
@@ -0,0 +1,95 @@
+/**********************************************************************************************************************
+  /dev/changer by Jeroen Massar aka fuzzel/unfix <jmassar@unfix.org>               http://unfix.org/projects/changer
+***********************************************************************************************************************
+ TAB=3
+ See changer.c for more info.
+**********************************************************************************************************************/
+#ifndef _CHANGER_H
+#define _CHANGER_H
+
+#include <linux/major.h>
+#include <linux/ioctl.h>
+#include <linux/types.h>
+#include <linux/kdev_t.h>
+
+#define CHANGER_SHORT			"changer"
+#define CHANGER_AUTHOR			"Jeroen Massar <jmassar@unfix.org>"
+#define CHANGER_FULL				"/dev/changer"
+#define CHANGER_WWW				"http://unfix.org/projects/changer"
+#define CHANGER_LIST				"changer@medusa.unfix.org"
+#define CHANGER_DATE				"19 May 1999"
+#define CHANGER_VERSION			19990519
+#define CHANGER_VERSION_SET	1
+
+#define CHANGER_DEVNAME	CHANGER_SHORT
+
+/* IOCTL */
+enum
+{
+	CHANGER_SET=_IO(CHANGER_MAJOR,42),
+	CHANGER_GET,
+	CHANGER_SET_LEVEL
+};
+
+/* Maximum of supported minor devices, thus the number of wrapped cd-slots. */
+#define CHANGER_MAX_MINOR	256		/* Change this if you need more. */
+#define CHANGER_NAME_LEN	20			/* Buffers can be overflowed so watch it. */
+
+/* Used with the CHANGER_SET/GET IOCTL
+   note that whenever (major==0&&minor==0&&slot==0&&name=="") that means the device is unused.
+	It is sufficient to check (major==0&&minor==0) for this case... */
+struct changer_set
+{
+	int		version;						/* Version (Should be CHANGER_VERSION_SET). */
+	int		size;							/* Structure size. */
+	int		major,minor;				/* The device (major:minor). */
+	int		slot;							/* Slot on the device. */
+	char		name[CHANGER_NAME_LEN];	/* The name the thing gets in /proc//sys/dev/cdrom/info. */
+												/* eg. "changer5". */
+};
+
+/* Stuff that only the kernel needs to know. */
+#ifdef __KERNEL__
+
+#include <linux/blkdev.h>
+#include <linux/cdrom.h>
+#include <linux/file.h>
+#include <linux/mm.h>
+#include <linux/fs.h>
+#include <asm/semaphore.h>
+
+/* Struct for devices in the changer array.
+   Represents a slot. */
+struct changer_dev
+{
+	kdev_t							dev;								/* Device (child's maj:min). */
+	int								opencount;						/* Use count (opens of the changer device). */
+	struct cdrom_device_info	cdi;								/* Cdrom Device Info. */
+	int								slot;								/* Slot of the device. (which slot this is on the device). */
+};
+
+/* Struct for keeping count of how many opens a specific device has.
+	This is for open/closes etc. As I only want and can open a device once. */
+struct changer_maj
+{
+	int								opencount;						/* How many slots I've opened on this device. */
+	int								minor[CHANGER_MAX_MINOR];	/* Which slot is which of my minors? (for changer_devs[.?.]. */
+	spinlock_t						spinlock;						/* Spinlock holding off changing of a device. */
+	struct cdrom_device_info	*cdi;								/* Cached pointer to the cdi. */
+	struct file						*file;							/* (Fake) file for this device. */
+	struct inode					inode;							/* Inode for the file. */
+	struct dentry					dentry;							/* Dentry for the file. */
+};
+
+#define LEVEL_NONE	0x0		/* None. */
+#define LEVEL_DEBUG	0x1		/* Debug Message. */
+#define LEVEL_FUNC	0x2		/* Function start/end. */
+#define LEVEL_XS		0x4		/* Access Messages (read/write functions). */
+#define LEVEL_INFO	0x8		/* Informational Messages. */
+#define LEVEL_ERR		0x16		/* Critical errors. */
+#define LEVEL_WARN	0x32		/* Warnings. */
+#define LEVEL_ANY		-1			/* All of the above. */
+
+#endif __KERNEL__
+#endif _CHANGER_H
+
diff -u --new-file --recursive linux-229/include/linux/major.h linux-229-changer/include/linux/major.h
--- linux-229/include/linux/major.h	Wed Oct 14 20:43:14 1998
+++ linux-229-changer/include/linux/major.h	Wed May 19 00:25:31 1999
@@ -72,6 +72,7 @@
 #define Z2RAM_MAJOR	37
 #define APBLOCK_MAJOR   38   /* AP1000 Block device */
 #define DDV_MAJOR       39   /* AP1000 DDV block device */
+#define CHANGER_MAJOR	42
 #define NBD_MAJOR	43   /* Network block device	*/
 #define RISCOM8_NORMAL_MAJOR 48
 #define RISCOM8_CALLOUT_MAJOR 49
diff -u --new-file --recursive linux-229/init/main.c linux-229-changer/init/main.c
--- linux-229/init/main.c	Tue May 11 18:57:14 1999
+++ linux-229-changer/init/main.c	Wed May 19 00:25:31 1999
@@ -344,6 +344,10 @@
 extern void md_setup(char *str,int *ints) __init;
 #endif
 
+#ifdef CONFIG_CHANGER
+extern void changer_setup(char *str,int *ints);
+#endif
+
 /*
  * Boot command-line arguments
  */
@@ -860,6 +864,9 @@
 #endif
 #ifdef CONFIG_LTPC
 	{ "ltpc=", ltpc_setup },
+#endif
+#ifdef CONFIG_CHANGER
+	{ "changer=",changer_setup },
 #endif
 	{ 0, 0 }
 };
